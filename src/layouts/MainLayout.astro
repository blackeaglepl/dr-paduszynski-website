---
/* @ts-nocheck */
export interface Props {
  title?: string;
  description?: string;
  hideHeader?: boolean;
  schemaType?: 'home' | 'pricing' | 'contact' | 'blog' | 'custom';
  customSchema?: any;
  // SEO dodatkowe
  image?: string;
  type?: string;
  keywords?: string;
  author?: string;
  canonical?: string;
  /**
   * Typ zawartości slotu pozostawiamy luźny, ale unikamy `any`.
   */
  children?: unknown;
}

import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import SchemaMarkup from '../components/SchemaMarkup.astro';
import { getLocaleFromUrl, locales, type Locale } from '../utils/i18n';
import '../styles/global.css';
---

<!doctype html>
<html lang={(locales[getLocaleFromUrl(Astro.url) as Locale]) ? getLocaleFromUrl(Astro.url) : 'pl'}>
  <head>
    <BaseHead 
      title={Astro.props.title} 
      description={Astro.props.description} 
      image={(Astro.props as Props).image}
      type={(Astro.props as Props).type}
      keywords={(Astro.props as Props).keywords}
      author={(Astro.props as Props).author}
      canonical={(Astro.props as Props).canonical}
    />
    <SchemaMarkup 
      schemaType={Astro.props.schemaType || 'home'} 
      customSchema={Astro.props.customSchema} 
    />
  </head>
  <body>
    {!(Astro.props as Props).hideHeader && <Header />}
    <main>
      <slot />
    </main>
    <Footer />
    <script is:inline>
      // Rejestracja Service Worker dla lepszego cache management
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/sw.js')
            .then((registration) => {
              console.log('SW zarejestrowany:', registration.scope);
            })
            .catch((error) => {
              console.log('SW nie został zarejestrowany:', error);
            });
        });

        // Funkcja do czyszczenia cache (dla debugowania)
        window.clearSiteCache = () => {
          if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            const channel = new MessageChannel();
            channel.port1.onmessage = (event) => {
              if (event.data === 'CACHE_CLEARED') {
                location.reload();
              }
            };
            navigator.serviceWorker.controller.postMessage('CLEAR_CACHE', [channel.port2]);
          } else {
            // Fallback - wyczyść localStorage i przeładuj
            localStorage.clear();
            sessionStorage.clear();
            location.reload();
          }
        };
      }

      // Lekki system animacji sekcji (AOS-like) bez zewnętrznych bibliotek
      (() => {
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const animatedElements = Array.from(document.querySelectorAll('[data-animate]'));

        /**
         * Ustawia stan początkowy na podstawie typu animacji.
         * Dostępne typy: fade, fade-up, fade-down, fade-left, fade-right, zoom-in, blur-in
         */
        const setInitialState = (el) => {
          const type = (el.getAttribute('data-animate') || 'fade-up').toLowerCase();
          el.classList.add('transition-all', 'duration-700', 'ease-out', 'will-change-transform', 'will-change-opacity');

          switch (type) {
            case 'fade':
              el.classList.add('opacity-0');
              break;
            case 'fade-down':
              el.classList.add('opacity-0', '-translate-y-6');
              break;
            case 'fade-left':
              el.classList.add('opacity-0', '-translate-x-6');
              break;
            case 'fade-right':
              el.classList.add('opacity-0', 'translate-x-6');
              break;
            case 'zoom-in':
              el.classList.add('opacity-0', 'scale-95');
              break;
            case 'blur-in':
              el.classList.add('opacity-0', 'blur-sm');
              break;
            case 'fade-up':
            default:
              el.classList.add('opacity-0', 'translate-y-6');
              break;
          }
        };

        /** Ustawia stan końcowy (widoczny) elementu */
        const reveal = (el) => {
          el.classList.add('opacity-100', 'translate-y-0', 'translate-x-0');
          el.classList.remove('opacity-0', 'translate-y-6', '-translate-y-6', 'translate-x-6', '-translate-x-6', 'scale-95', 'blur-sm');
          el.classList.add('blur-0', 'scale-100');
        };

        /** Resetuje do stanu początkowego (dla trybu powtarzalnego) */
        const reset = (el) => {
          el.classList.remove('opacity-100', 'translate-y-0', 'scale-100', 'blur-0');
          // Przywróć klasę początkową zależną od typu
          const type = (el.getAttribute('data-animate') || 'fade-up').toLowerCase();
          switch (type) {
            case 'fade':
              el.classList.add('opacity-0');
              break;
            case 'fade-down':
              el.classList.add('opacity-0', '-translate-y-6');
              break;
            case 'fade-left':
              el.classList.add('opacity-0', '-translate-x-6');
              break;
            case 'fade-right':
              el.classList.add('opacity-0', 'translate-x-6');
              break;
            case 'zoom-in':
              el.classList.add('opacity-0', 'scale-95');
              break;
            case 'blur-in':
              el.classList.add('opacity-0', 'blur-sm');
              break;
            case 'fade-up':
            default:
              el.classList.add('opacity-0', 'translate-y-6');
              break;
          }
        };

        // Inicjalizacja
        animatedElements.forEach(setInitialState);

        // Jeśli użytkownik preferuje ograniczony ruch — pokaż od razu
        if (prefersReducedMotion) {
          animatedElements.forEach((el) => {
            el.classList.remove('opacity-0', 'translate-y-6', '-translate-y-6', 'translate-x-6', '-translate-x-6', 'scale-95', 'blur-sm');
            el.classList.add('opacity-100', 'translate-y-0', 'scale-100', 'blur-0');
          });
          return;
        }

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              const el = entry.target;
              const once = el.getAttribute('data-animate-repeat') !== 'true';
              const delay = parseInt(el.getAttribute('data-animate-delay') || '0', 10) || 0;

              if (entry.isIntersecting) {
                if (delay > 0) {
                  setTimeout(() => reveal(el), delay);
                } else {
                  reveal(el);
                }
                if (once) observer.unobserve(el);
              } else if (!once) {
                reset(el);
              }
            });
          },
          { threshold: 0.2 }
        );

        animatedElements.forEach((el) => observer.observe(el));
      })();
    </script>
  </body>
  </html>


